module UsefulFunctions
  use kinds
  implicit none

contains

	SUBROUTINE fourrow_sp(data,isign)
	USE nrtype; USE nrutil, ONLY : assert,swap
	IMPLICIT NONE
	COMPLEX(SPC), DIMENSION(:,:), INTENT(INOUT) :: data
	INTEGER(I4B), INTENT(IN) :: isign
	INTEGER(I4B) :: n,i,istep,j,m,mmax,n2
	REAL(DP) :: theta
	COMPLEX(SPC), DIMENSION(size(data,1)) :: temp
	COMPLEX(DPC) :: w,wp
	COMPLEX(SPC) :: ws
	n=size(data,2)
	call assert(iand(n,n-1)==0, 'n must be a power of 2 in fourrow_sp')
	n2=n/2
	j=n2
	do i=1,n-2
		if (j > i) call swap(data(:,j+1),data(:,i+1))
		m=n2
		do
			if (m < 2 .or. j < m) exit
			j=j-m
			m=m/2
		end do
		j=j+m
	end do
	mmax=1
	do
		if (n <= mmax) exit
		istep=2*mmax
		theta=PI_D/(isign*mmax)
		wp=cmplx(-2.0_dp*sin(0.5_dp*theta)**2,sin(theta),kind=dpc)
		w=cmplx(1.0_dp,0.0_dp,kind=dpc)
		do m=1,mmax
			ws=w
			do i=m,n,istep
				j=i+mmax
				temp=ws*data(:,j)
				data(:,j)=data(:,i)-temp
				data(:,i)=data(:,i)+temp
			end do
			w=w*wp+w
		end do
		mmax=istep
	end do
	END SUBROUTINE fourrow_sp

	SUBROUTINE fourrow_dp(data,isign)
	USE nrtype; USE nrutil, ONLY : assert,swap
	IMPLICIT NONE
	COMPLEX(DPC), DIMENSION(:,:), INTENT(INOUT) :: data
	INTEGER(I4B), INTENT(IN) :: isign
	INTEGER(I4B) :: n,i,istep,j,m,mmax,n2
	REAL(DP) :: theta
	COMPLEX(DPC), DIMENSION(size(data,1)) :: temp
	COMPLEX(DPC) :: w,wp
	COMPLEX(DPC) :: ws
	n=size(data,2)
	call assert(iand(n,n-1)==0, 'n must be a power of 2 in fourrow_dp')
	n2=n/2
	j=n2
	do i=1,n-2
		if (j > i) call swap(data(:,j+1),data(:,i+1))
		m=n2
		do
			if (m < 2 .or. j < m) exit
			j=j-m
			m=m/2
		end do
		j=j+m
	end do
	mmax=1
	do
		if (n <= mmax) exit
		istep=2*mmax
		theta=PI_D/(isign*mmax)
		wp=cmplx(-2.0_dp*sin(0.5_dp*theta)**2,sin(theta),kind=dpc)
		w=cmplx(1.0_dp,0.0_dp,kind=dpc)
		do m=1,mmax
			ws=w
			do i=m,n,istep
				j=i+mmax
				temp=ws*data(:,j)
				data(:,j)=data(:,i)-temp
				data(:,i)=data(:,i)+temp
			end do
			w=w*wp+w
		end do
		mmax=istep
	end do
	END SUBROUTINE fourrow_dp

	SUBROUTINE fourcol(data,isign)
	USE nrtype; USE nrutil, ONLY : assert,swap
	IMPLICIT NONE
	COMPLEX(SPC), DIMENSION(:,:), INTENT(INOUT) :: data
	INTEGER(I4B), INTENT(IN) :: isign
	INTEGER(I4B) :: n,i,istep,j,m,mmax,n2
	REAL(DP) :: theta
	COMPLEX(SPC), DIMENSION(size(data,2)) :: temp
	COMPLEX(DPC) :: w,wp
	COMPLEX(SPC) :: ws
	n=size(data,1)
	call assert(iand(n,n-1)==0, 'n must be a power of 2 in fourcol')
	n2=n/2
	j=n2
	do i=1,n-2
		if (j > i) call swap(data(j+1,:),data(i+1,:))
		m=n2
		do
			if (m < 2 .or. j < m) exit
			j=j-m
			m=m/2
		end do
		j=j+m
	end do
	mmax=1
	do
		if (n <= mmax) exit
		istep=2*mmax
		theta=PI_D/(isign*mmax)
		wp=cmplx(-2.0_dp*sin(0.5_dp*theta)**2,sin(theta),kind=dpc)
		w=cmplx(1.0_dp,0.0_dp,kind=dpc)
		do m=1,mmax
			ws=w
			do i=m,n,istep
				j=i+mmax
				temp=ws*data(j,:)
				data(j,:)=data(i,:)-temp
				data(i,:)=data(i,:)+temp
			end do
			w=w*wp+w
		end do
		mmax=istep
	end do
	END SUBROUTINE fourcol

	SUBROUTINE four1_sp(data,isign)
	USE nrtype; USE nrutil, ONLY : arth,assert
	USE nr, ONLY : fourrow
	IMPLICIT NONE
	COMPLEX(SPC), DIMENSION(:), INTENT(INOUT) :: data
	INTEGER(I4B), INTENT(IN) :: isign
	COMPLEX(SPC), DIMENSION(:,:), ALLOCATABLE :: dat,temp
	COMPLEX(DPC), DIMENSION(:), ALLOCATABLE :: w,wp
	REAL(DP), DIMENSION(:), ALLOCATABLE :: theta
	INTEGER(I4B) :: n,m1,m2,j
	n=size(data)
	call assert(iand(n,n-1)==0, 'n must be a power of 2 in four1_sp')
	m1=2**ceiling(0.5_sp*log(real(n,sp))/0.693147_sp)
	m2=n/m1
	allocate(dat(m1,m2),theta(m1),w(m1),wp(m1),temp(m2,m1))
	dat=reshape(data,shape(dat))
	call fourrow(dat,isign)
	theta=arth(0,isign,m1)*TWOPI_D/n
	wp=cmplx(-2.0_dp*sin(0.5_dp*theta)**2,sin(theta),kind=dpc)
	w=cmplx(1.0_dp,0.0_dp,kind=dpc)
	do j=2,m2
		w=w*wp+w
		dat(:,j)=dat(:,j)*w
	end do
	temp=transpose(dat)
	call fourrow(temp,isign)
	data=reshape(temp,shape(data))
	deallocate(dat,w,wp,theta,temp)
	END SUBROUTINE four1_sp

	SUBROUTINE four1_dp(data,isign)
	USE nrtype; USE nrutil, ONLY : arth,assert
	USE nr, ONLY : fourrow
	IMPLICIT NONE
	COMPLEX(DPC), DIMENSION(:), INTENT(INOUT) :: data
	INTEGER(I4B), INTENT(IN) :: isign
	COMPLEX(DPC), DIMENSION(:,:), ALLOCATABLE :: dat,temp
	COMPLEX(DPC), DIMENSION(:), ALLOCATABLE :: w,wp
	REAL(DP), DIMENSION(:), ALLOCATABLE :: theta
	INTEGER(I4B) :: n,m1,m2,j
	n=size(data)
	call assert(iand(n,n-1)==0, 'n must be a power of 2 in four1_dp')
	m1=2**ceiling(0.5_sp*log(real(n,sp))/0.693147_sp)
	m2=n/m1
	allocate(dat(m1,m2),theta(m1),w(m1),wp(m1),temp(m2,m1))
	dat=reshape(data,shape(dat))
	call fourrow(dat,isign)
	theta=arth(0,isign,m1)*TWOPI_D/n
	wp=cmplx(-2.0_dp*sin(0.5_dp*theta)**2,sin(theta),kind=dpc)
	w=cmplx(1.0_dp,0.0_dp,kind=dpc)
	do j=2,m2
		w=w*wp+w
		dat(:,j)=dat(:,j)*w
	end do
	temp=transpose(dat)
	call fourrow(temp,isign)
	data=reshape(temp,shape(data))
	deallocate(dat,w,wp,theta,temp)
	END SUBROUTINE four1_dp

	SUBROUTINE four2(data,isign)
	USE nrtype
	USE nr, ONLY : fourrow
	IMPLICIT NONE
	COMPLEX(SPC), DIMENSION(:,:), INTENT(INOUT) :: data
	INTEGER(I4B), INTENT(IN) :: isign
	COMPLEX(SPC), DIMENSION(size(data,2),size(data,1)) :: temp
	call fourrow(data,isign)
	temp=transpose(data)
	call fourrow(temp,isign)
	data=transpose(temp)
	END SUBROUTINE four2

	SUBROUTINE four3(data,isign)
	USE nrtype
	USE nr, ONLY : fourrow_3d
	IMPLICIT NONE
	COMPLEX(SPC), DIMENSION(:,:,:), INTENT(INOUT) :: data
	INTEGER(I4B), INTENT(IN) :: isign
	COMPLEX(SPC), DIMENSION(:,:,:), ALLOCATABLE :: dat2,dat3
	call fourrow_3d(data,isign)
	allocate(dat2(size(data,2),size(data,3),size(data,1)))
	dat2=reshape(data,shape=shape(dat2),order=(/3,1,2/))
	call fourrow_3d(dat2,isign)
	allocate(dat3(size(data,3),size(data,1),size(data,2)))
	dat3=reshape(dat2,shape=shape(dat3),order=(/3,1,2/))
	deallocate(dat2)
	call fourrow_3d(dat3,isign)
	data=reshape(dat3,shape=shape(data),order=(/3,1,2/))
	deallocate(dat3)
	END SUBROUTINE four3

  function linspace(start,finish,N)
    integer, intent(in)    :: start, finish
    integer                :: N
    real(dp), dimension(N) :: linspace
    
    real(dp)               :: int
    integer                :: i
    
    linspace(1) = real(start)
    linspace(N) = real(finish)
    int  = (real(finish)-start)/N

    do i=2,N-1
       linspace(i)=linspace(i-1)+int
    end do

  end function linspace

  
end module UsefulFunctions
