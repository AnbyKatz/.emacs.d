program test
  use usefulFunctions
  use Kinds
  use Pyplots
  implicit none

!-------------------------------------------------------------------------!
! Below contains code which reproduces plots from the 1996 QMC            !
! finite nuclei paper. One run calculates the plots using the fits        !
! for the effective nucleon mass and the parameter C. For further         !
! details on the applied formulas, see the proofs given in attached       !
! tex document.                                                           !
!-------------------------------------------------------------------------!
  
  integer                             :: ii,jj,ID,guess,counter,N,mm
  character(len=11),dimension(3)      :: legend
  real(DP),dimension(:),  allocatable :: x_ax1,x_ax2,y_ax,Meffvals,Cvals
  real(DP),dimension(:,:),allocatable :: data1,data2,data3
  real(DP),dimension(3)               :: couple,BagRadii  

  real(DP)                            :: x,Mq,Mn,fmMeV,Bag,z0,    &
                                         Msigma,Rho0,RB,S0,Sr,    &
                                         sigma,a,b,absErr,relErr, &
                                         Omega0,g_sigma,V,yval,   &
                                         dOmega0,ed,dx,rho_in,    &
                                         maxDen,RhoB,testvar

  !---------------------------------------------------------------------!
  !                                                                     !
  !                           Parameters Below                          !
  !                                                                     !
  !---------------------------------------------------------------------!

  ! Conversion Factor
  fmMeV       = 1/(197.327_DP)  !for fm -> MeV^{-1}

  ! Set model parameters
  couple(1)   = sqrt(5.86*4*pi) !constant
  couple(2)   = sqrt(5.40*4*pi) !constant
  couple(3)   = sqrt(5.07*4*pi) !constant
  BagRadii(1) = 0.60_DP         !fm
  BagRadii(2) = 0.80_DP         !fm
  BagRadii(3) = 1.00_DP         !fm
  Mq          = 5.0_DP          !MeV
  Mn          = 939.565_DP      !MeV
  Rho0        = 0.16_DP         !fm^{-3}
  Msigma      = 550.0_DP        !MeV

  ! Integration Parameters
  absErr      = 1e-6_DP
  relErr      = 1e-6_DP
  a           = 0.0_DP

  ! Results file to write to
  open(100,file="1996_Results.dat",action="write", &
       & status="replace",form="formatted")

  do ii = 1,3
     write(legend(ii),'(a5,f3.1,a3)') "RB = ",BagRadii(ii)," fm"
  end do

  ! Choose whether to run the code using the fit
  ! parameters or solving the bag equations for
  ! the parameters themselves


  call QMC_nofit()


  close(100)

contains

  !---------------------------------------------------------------------!
  !                                                                     !
  !                       Plots without fit (SLOW)                      !
  !                                                                     !
  !---------------------------------------------------------------------!

  subroutine QMC_nofit()
    use Kinds
    implicit none

    N     = 1e3
    allocate(x_ax1(N),x_ax2(N),y_ax(N),&
         data1(N,6),data2(N,6),data3(N,6),&
         Meffvals(N),Cvals(N))

    ! jj = 1
    do jj = 1,3

       RB      = BagRadii(jj)*fmMeV
       g_sigma = couple(jj)
       V       = (4/3.0)*pi*(RB**3)
       ed      = 500.0_DP
       maxDen  = Rho0*2.0_DP 

       ! Density values to use
       x_ax1 = linspace(0.001_dp,maxDen,N) 
       ! scalar meson values to use
       x_ax2   = linspace(0.001_dp,ed/g_sigma,N)

       call cal_xOmega0(RB,Mq,x,Omega0)

       dx      = deriv(xderiv,RB)
       dOmega0 = 2*((Mq**2)*RB+dx*x)/Omega0
       Bag     = (3.0/(16.0*pi*(RB**3)))*(MN - 3.0*dOmega0 )
       z0      = 3.0*Omega0 - MN*RB + Bag*(4.0/3.0)*pi*(RB**4)
       S0      = (Omega0/2+Mq*RB*(Omega0-1))&
            /(Omega0*(Omega0-1)+(Mq*RB)/2)

       do ii = 1,N
          sigma = x_ax2(ii)
          Meffvals(ii) = Meff(sigma)       
          Cvals(ii)    = C(sigma)
       end do

       do ii = 1,N
          RhoB = x_ax1(ii)*(fmMeV**(-3))
          b = (3*(pi**2)*RhoB/2)**(1/3.0)
          call cal_SMF(yval)
          data1(ii,2*jj) = yval
       end do

       do ii = 1,N
          sigma = data1(ii,2*jj)
          data2(ii,2*jj) = Meff(sigma)
          data3(ii,2*jj) = C(sigma)
       end do

       data1(:,2*jj)   = data1(:,2*jj)*g_sigma
       data1(:,2*jj-1) = x_ax1/Rho0
       data2(:,2*jj-1) = data1(:,2*jj-1)
       data3(:,2*jj-1) = data1(:,2*jj)

    end do

    ! call plot(data1(:,2*jj-1:2*jj))
    ! call plot(data2(:,2*jj-1:2*jj))
    ! call plot(data3(:,2*jj-1:2*jj))
    Call plot(data1,"ρ/ρ₀","(g_σ)σ (MeV)",legend)

    deallocate(x_ax1,x_ax2,y_ax,&
         data1,data2,data3)

  end subroutine QMC_nofit

 !-----------------------------------------------------------------------!
 !-----------------------------------------------------------------------!
 !-----------------------------------------------------------------------!

  !---------------------------------------------------------------------!
  !                                                                     !
  !                    Calculates Bag constant and z0                   !
  !                                                                     !
  !---------------------------------------------------------------------!

  subroutine cal_xOmega0(RB,Mq,x,Omega0)
    real(DP), intent(in)   :: RB,Mq
    real(DP), intent(out)  :: x,Omega0

    real(DP)               :: xleft,xright,guess

    xleft  = 0.01_DP
    xright = 3.3_DP
    guess  = GuessZeroNew(Boundary_f,xleft,xright)
    x      = newton1D(Boundary_f,guess)
    Omega0 = sqrt( x**2 + (Mq*RB)**2 )

  end subroutine cal_xOmega0

  subroutine cal_xOmega02(RB,Omega0)
    real(DP), intent(in)   :: RB
    real(DP), intent(out)  :: Omega0

    real(DP)               :: xleft,xright,guess,x

    xleft  = 0.01_DP
    xright = 3.3_DP
    guess  = GuessZeroNew(Boundary_f2,xleft,xright)
    x      = newton1D(Boundary_f2,guess)
    Omega0 = sqrt( x**2 + (Mqef(sigma)*RB)**2 )

  end subroutine cal_xOmega02

  !---------------------------------------------------------------------!
  !                                                                     !
  !                 Calculates x from boundary condition                !
  !                                                                     !
  !---------------------------------------------------------------------!

  function Boundary_f(x)
    real(DP),intent(in) :: x
    real(DP)            :: Boundary_f

    Boundary_f = -(sqrt( (sqrt( x**2+(Mq*RB)**2 ) - Mq*RB ) &
                 /( sqrt( x**2+(Mq*RB)**2 ) + Mq*RB ) ))* &
                 (sin(x)/(x**2)-cos(x)/x) + sin(x)/x
    
  end function Boundary_f
  
  function Boundary_f2(x)
    real(DP),intent(in) :: x
    real(DP)            :: Boundary_f2

    Boundary_f2 = -(sqrt( (sqrt( x**2+(Mqef(sigma)*RB)**2 ) - Mqef(sigma)*RB ) &
                 /( sqrt( x**2+(Mqef(sigma)*RB)**2 ) + Mqef(sigma)*RB ) ))* &
                 (sin(x)/(x**2)-cos(x)/x) + sin(x)/x
    
  end function Boundary_f2

  !---------------------------------------------------------------------!
  !                                                                     !
  !                              C function                             !
  !                                                                     !
  !---------------------------------------------------------------------!

  function C(sigma)
    real(DP),intent(in) :: sigma
    real(DP)            :: C

    real(DP)            :: Omeg

    call cal_xOmega02(RB,Omeg)
    C = ((Omeg/2+Mqef(sigma)*RB*(Omeg-1))&
        /(Omeg*(Omeg-1)+(Mqef(sigma)*RB)/2))/S0

  end function C

  function Mqef(sigma)
    real(DP),intent(in) :: sigma
    real(DP)            :: Mqef

    Mqef = Mq - (1/(3*S0))*g_sigma*sigma

  end function Mqef

  function Meff(sigma)
    real(DP),intent(in) :: sigma
    real(DP)            :: Meff

    real(DP)            :: Omeg

    call cal_xOmega02(RB,Omeg)
    Meff = (3*Omeg-z0)/RB + Bag*V

  end function Meff

  !---------------------------------------------------------------------!
  !                                                                     !
  !                          Scalar Meson Field                         !
  !                                                                     !
  !---------------------------------------------------------------------!

  subroutine cal_SMF(yval)
    real(DP),intent(out)  :: yval
    real(DP),dimension(N) :: yvals

    do mm = 1,N
       sigma = x_ax2(mm)
       yvals(mm) =  (g_sigma/Msigma**2)*Cvals(mm)*(2/pi**2)*&
            integral(SMF_Integral,a,b,absErr,relErr)-sigma
    end do


    ! guess = GuessZero(yvals)
    ! yval = newton1D(SMF_newton,x_ax2(guess))

    guess = GuessZero(yvals)
    yval = x_ax2(guess)

  end subroutine  cal_SMF

  function SMF_Integral(k)
    real(DP),intent(in) :: k
    real(DP)            :: SMF_Integral

    SMF_Integral = (Meffvals(mm)*(k**2))/(sqrt( Meffvals(mm)**2+k**2))

  end function SMF_Integral

  !---------------------------------------------------------------------!
  !                                                                     !
  !                          SMF zeros equation                         !
  !                                                                     !
  !---------------------------------------------------------------------!

  function SMF_newton(x)
    real(DP),intent(in) :: x
    real(DP)            :: SMF_newton

    testvar = x
    SMF_newton = (g_sigma/Msigma**2)*C(x)*(2/pi**2)*&
            integral(SMF_Integral_Func,a,b,absErr,relErr)-x

  end function SMF_newton

  function SMF_Integral_Func(k)
    real(DP),intent(in) :: k
    real(DP)            :: SMF_Integral_Func

    SMF_Integral_Func = (Meff(testvar)*(k**2))/(sqrt( Meff(testvar)**2+k**2))

  end function SMF_Integral_Func

  !---------------------------------------------------------------------!
  !                                                                     !
  !                  Numerically calculate x derivative                 !
  !                                                                     !
  !---------------------------------------------------------------------!

  function xderiv(RB)
    real(DP),intent(in) :: RB
    real(DP)            :: xderiv

    xderiv = sqrt( Omega0**2 - (Mq*RB)**2 )

  end function xderiv

end program
