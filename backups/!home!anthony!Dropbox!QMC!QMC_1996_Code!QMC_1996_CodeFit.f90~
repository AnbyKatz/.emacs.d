Program QMC_1996_CodeVFinal
  Use usefulFunctions
  Use Kinds
  Use Pyplots
  Implicit None

!-------------------------------------------------------------------------!
! Below contains code which reproduces plots from the 1996 QMC            !
! finite nuclei paper. One run calculates the plots using the fits        !
! for the effective nucleon mass and the parameter C. For further         !
! details on the applied formulas, see the proofs given in attached       !
! tex document.                                                           !
!-------------------------------------------------------------------------!
  
  Integer                             :: ii,jj,ID,guess,counter,N
  Character(len=11),Dimension(3)      :: legend
  Real(DP),Dimension(:),  Allocatable :: x_ax1,x_ax2,y_ax
  Real(DP),Dimension(:,:),Allocatable :: data1,data2,data3
  Real(DP),Dimension(3)               :: couple,BagRadii  

  Real(DP)                            :: x,Mq,Mn,fmMeV,Bag,z0,SIGfield, &
                                         Msigma,Rho0,RhoB,RB,S1,S2,     &
                                         sigma,a,b,absErr,relErr,       &
                                         Omega0,g_sigma,Meff,V,C,Mqef,  &
                                         dOmega0,var,xx,yval,ed,dx,d

  !---------------------------------------------------------------------!
  !                                                                     !
  !                           Parameters Below                          !
  !                                                                     !
  !---------------------------------------------------------------------!

  ! Conversion Factor
  fmMeV       = 1/(197.327_DP)  !for fm -> MeV^{-1}

  ! Set model parameters
  couple(1)   = Sqrt(5.86*4*pi) !constant
  couple(2)   = Sqrt(5.40*4*pi) !constant
  couple(3)   = Sqrt(5.07*4*pi) !constant
  BagRadii(1) = 0.60_DP         !fm
  BagRadii(2) = 0.80_DP         !fm
  BagRadii(3) = 1.00_DP         !fm
  Mq          = 5.0_DP          !MeV
  Mn          = 939.565_DP      !MeV
  Rho0        = 0.16_DP         !fm^{-3}
  Msigma      = 550.0_DP        !MeV

  ! Integration Parameters
  absErr      = 1e-6_DP
  relErr      = 1e-6_DP
  a           = 0.0_DP

  ! Results file to write to
  Open(100,file="1996_Results.dat",action="write", &
       & status="replace",form="formatted")

  Do ii = 1,3
     Write(legend(ii),'(a5,f3.1,a3)') "RB = ",BagRadii(ii)," fm"
  End Do

  ! Choose whether to run the code using the fit
  ! parameters or solving the bag equations for
  ! the parameters themselves


  Call QMC_fit()
  ! Call QMC_nofit()


  Close(100)

Contains

  !---------------------------------------------------------------------!
  !                                                                     !
  !                    Subroutines & Functions Below                    !
  !                                                                     !
  !---------------------------------------------------------------------!

 !-----------------------------------------------------------------------!
 !-----------------------------------------------------------------------!
 !-----------------------------------------------------------------------!

  !---------------------------------------------------------------------!
  !                                                                     !
  !                        Plots with fit (FAST)                        !
  !                                                                     !
  !---------------------------------------------------------------------!

  Subroutine QMC_fit()
    Use Kinds
    Implicit None

    N       = 1e3
    counter = 1
    Allocate(x_ax1(N),x_ax2(N),y_ax(N),&
         data1(N,6),data2(N,6),data3(N,6))

    ! Maximum value for (g_σ)σ (MeV) 
    ed      = 500.0_DP
    ! range of values for ρ_B
    x_ax1   = linspace(0.001_dp,Rho0*2.5,N) 

    Do ii = 2,6,2    

       g_sigma = couple(counter)
       RB      = BagRadii(counter)*fmMeV
       d       = 0.22*RB
       Mqef    = Mq

       ! range of values for (g_σ)σ 
       x_ax2   = linspace(0.001_dp,ed/g_sigma,N)

       Call cal_xOmega0(RB,Mqef,x,Omega0)
       dx      = deriv(xderiv,RB)
       dOmega0 = 2*((Mqef**2)*RB+dx*x)/Omega0
       Bag     = (3.0/(16.0*pi*(RB**3)))*(MN - 3.0*dOmega0 )
       z0      = 3.0*Omega0 - MN*RB + Bag*(4.0/3.0)*pi*(RB**4)
       Write(100,'(2f12.4)') Bag**(1/4.0),z0

       ! Calculates the scalar meson field values
       ! σ and stores them in data1
       Call cal_SMF_fit(data1(:,ii))
       data1(:,ii) = data1(:,ii)*g_sigma
       Call cal_MeffC(data1(:,ii),data2(:,ii),data3(:,ii))
       counter     = counter+1

    End Do

    ! Scale x_axis to multiples of nuclear matter
    x_ax1 = x_ax1/Rho0

    Do ii = 1,5,2
       data1(:,ii) = x_ax1         !data1 = (g_σ)σ VS ρ/ρ₀
       data2(:,ii) = x_ax1         !data2 = Mₙ* VS ρ/ρ₀
       data3(:,ii) = data1(:,ii+1) !data3 = C VS (g_σ)σ
    End Do

    ! See pyplots.f90 for more detail on
    ! the plotting algorithim
    Call plot(data1,"ρ/ρ₀","(g_σ)σ (MeV)",legend)
    Call plot(data2,"ρ/ρ₀","Mₙ* (MeV)",legend)
    Call plot(data3,"(g_σ)σ (MeV)","C",legend)

    Deallocate(x_ax1,x_ax2,y_ax,&
         data1,data2,data3)

  End Subroutine QMC_fit

  !---------------------------------------------------------------------!
  !                                                                     !
  !                       Plots without fit (SLOW)                      !
  !                                                                     !
  !---------------------------------------------------------------------!

  Subroutine QMC_nofit()
    Use Kinds
    Implicit None

    N     = 1e3
    ed    = 400_DP                        
    Allocate(x_ax1(N),x_ax2(N),y_ax(N),&
         data1(N,6),data2(N,6),data3(N,6))
    x_ax1 = linspace(0.001_dp,Rho0*2.0,N) 

    Do jj = 1,3                   

       Mqef    = Mq
       RB      = BagRadii(jj)*fmMeV
       g_sigma = couple(jj)
       V       = (4/3.0)*pi*(RB**3)
       x_ax2   = linspace(0.001_dp,ed/g_sigma,N)

       Call cal_xOmega0(RB,Mqef,x,Omega0)

       dx      = deriv(xderiv,RB)
       dOmega0 = 2*((Mqef**2)*RB+dx*x)/Omega0
       Bag     = (3.0/(16.0*pi*(RB**3)))*(MN - 3.0*dOmega0 )
       z0      = 3.0*Omega0 - MN*RB + Bag*(4.0/3.0)*pi*(RB**4)
       S1      = (Omega0/2+Mqef*RB*(Omega0-1))&
            /(Omega0*(Omega0-1)+(Mqef*RB)/2)

       Do ii = 1,N
          sigma = x_ax2(ii)
          Mqef  = Mq - (1/(3*S1))*g_sigma*sigma     
          Call cal_xOmega0(RB,Mqef,x,Omega0)
          
          S2    = (Omega0/2+Mqef*RB*(Omega0-1))&
               /(Omega0*(Omega0-1)+(Mqef*RB)/2)

          C     = S2/S1
          Meff  = (3*Omega0-z0)/RB + Bag*V
          xx    = x_ax1(ii)
          Call cal_SMF_nofit(yval)
          data1(ii,2*jj) = yval*g_sigma
          data2(ii,2*jj) = Meff
          data3(ii,2*jj) = C

       End Do

    End Do

    x_ax1 = x_ax1/Rho0

    Do ii = 1,5,2
       data1(:,ii) = x_ax1         !data1 = (g_σ)σ VS ρ/ρ₀
       data2(:,ii) = x_ax1         !data2 = Mₙ* VS ρ/ρ₀
       data3(:,ii) = data1(:,ii+1) !data3 = C VS (g_σ)σ
    End Do

    Call plot(data1,"ρ/ρ₀","(g_σ)σ (MeV)",legend)
    Call plot(data2,"ρ/ρ₀","Mₙ* (MeV)",legend)
    Call plot(data3,"(g_σ)σ (MeV)","C",legend)

    Deallocate(x_ax1,x_ax2,y_ax,&
         data1,data2,data3)

  End Subroutine QMC_nofit

 !-----------------------------------------------------------------------!
 !-----------------------------------------------------------------------!
 !-----------------------------------------------------------------------!

  !---------------------------------------------------------------------!
  !                                                                     !
  !                    Calculates Bag constant and z0                   !
  !                                                                     !
  !---------------------------------------------------------------------!

  Subroutine cal_xOmega0(RB,Mqef,x,Omega0)
    Real(DP), Intent(in)   :: RB,Mqef
    Real(DP), Intent(out)  :: x,Omega0

    Real(DP)               :: xleft,xright,guess

    xleft  = 0.01_DP
    xright = 3.3_DP
    guess  = GuessZeroNew(Boundary_f,xleft,xright)
    x      = newton1D(Boundary_f,guess)
    Omega0 = Sqrt( x**2 + (Mqef*RB)**2 )

  End Subroutine cal_xOmega0

  !---------------------------------------------------------------------!
  !                                                                     !
  !                   Calculates Effective Mass and C                   !
  !                                                                     !
  !---------------------------------------------------------------------!

  Subroutine cal_MeffC(xvals,Meff,C)
    Use Kinds
    Implicit None

    Real(DP),Dimension(:),Intent(in)  :: xvals
    Real(DP),Dimension(:),Intent(out) :: Meff,C

    Meff = MN - (1-(d/2)*xvals)*xvals
    C    = 1 - d*xvals

  End Subroutine cal_MeffC

  !---------------------------------------------------------------------!
  !                                                                     !
  !                 Calculates x from boundary condition                !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function Boundary_f(x)
    Real(DP),Intent(in) :: x
    Real(DP)            :: Boundary_f

    Boundary_f = -(Sqrt( (Sqrt( x**2+(Mqef*RB)**2 ) - Mqef*RB ) &
                 /( Sqrt( x**2+(Mqef*RB)**2 ) + Mqef*RB ) ))* &
                 (Sin(x)/(x**2)-Cos(x)/x) + Sin(x)/x
    
  End Function Boundary_f

  !---------------------------------------------------------------------!
  !                                                                     !
  !                  Numerically calculate x derivative                 !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function xderiv(RB)
    Real(DP),Intent(in) :: RB
    Real(DP)            :: xderiv

    xderiv = Sqrt( Omega0**2 - (Mqef*RB)**2 )

  End Function xderiv

 !-----------------------------------------------------------------------!
 !-----------------------------------------------------------------------!
 !-----------------------------------------------------------------------!

  !---------------------------------------------------------------------!
  !                                                                     !
  !                  Subroutines/Functions for fit run                  !
  !                                                                     !
  !---------------------------------------------------------------------!

  Subroutine cal_SMF_fit(yvals)
    Use Kinds
    Implicit None

    Real(DP),Dimension(N),Intent(out) :: yvals

    Real(DP),Dimension(N)             :: yy
    Integer                           :: kk

    x_ax2 = linspace(0.001_dp,ed/g_sigma,N) !MeV

    Do jj = 1,N

       RhoB = x_ax1(jj)*(fmMeV**(-3))    !MeV^{3}
       b    =(3*(pi**2)*RhoB/2)**(1/3.0) !MeV

       Do kk = 1,N
          sigma  = x_ax2(kk)
          yy(kk) = (((g_sigma/Msigma**2)*(1-d*g_sigma*sigma)*(2/pi**2))&
                   *integral(SMF_integral_fit,a,b,absErr,relErr))-sigma
       End Do

       guess     = GuessZero(yy)
       yvals(jj) = newton1D(SMF_newton_fit,x_ax2(guess))

    End Do

  End Subroutine cal_SMF_fit

  Function SMF_integral_fit(x)
    Use Kinds
    Implicit None

    Real(DP), Intent(in) :: x
    Real(DP)             :: SMF_integral_fit

    Real(DP)             :: Meff

    Meff             = MN - (1-(d/2)*g_sigma*sigma)*g_sigma*sigma
    SMF_integral_fit = (Meff*(x**2))/(Sqrt( Meff**2 + x**2 ))

  End Function SMF_integral_fit

  Function SMF_newton_fit(x)
    Use Kinds
    Implicit None

    Real(DP), Intent(in) :: x
    Real(DP)             :: SMF_newton_fit

    sigma          = x
    SMF_newton_fit = (((g_sigma/Msigma**2)*(1-d*g_sigma*x)*(2/pi**2))&
                     *integral(SMF_integral_fit,a,b,absErr,relErr))-x

  End Function SMF_newton_fit

  !---------------------------------------------------------------------!
  !                                                                     !
  !                 Subroutines/Functions for no fit run                !
  !                                                                     !
  !---------------------------------------------------------------------!

  Subroutine cal_SMF_nofit(yval)
    Real(DP),Intent(out)  :: yval

    Real(DP),Dimension(N) :: yvals
    Integer               :: kk

    RhoB = xx*(fmMeV**(-3))           !MeV^{3}
    b    =(3*(pi**2)*RhoB/2)**(1/3.0) !MeV

    Do kk = 1,N
       var       = x_ax2(kk) 
       yvals(kk) = (((g_sigma/Msigma**2)*C*(2/pi**2))&
                   *integral(SMF_integral_nofit,a,b,absErr,relErr))- var
    End Do

    guess = GuessZero(yvals)
    yval  = newton1D(SMF_newton_nofit,x_ax2(guess))

  End Subroutine cal_SMF_nofit

  Function SMF_integral_nofit(x)
    Real(DP), Intent(in) :: x    
    Real(DP)             :: SMF_integral_nofit

    SMF_integral_nofit = (Meff*(x**2))/(Sqrt( Meff**2 + x**2 ))

  End Function SMF_integral_nofit

  Function SMF_newton_nofit(x)
    Real(DP),Intent(in) :: x
    Real(DP)            :: SMF_newton_nofit

    var              = x
    SMF_newton_nofit = (((g_sigma/Msigma**2)*C*(2/pi**2))&
                       *integral(SMF_integral_nofit,a,b,absErr,relErr))-x

  End Function SMF_newton_nofit

End Program QMC_1996_CodeVFinal
