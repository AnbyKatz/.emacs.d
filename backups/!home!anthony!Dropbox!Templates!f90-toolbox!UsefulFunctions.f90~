Module UsefulFunctions
  Use kinds
  Use quadpack
  Implicit None

  Real(DP), Parameter :: Infty = Huge(1.0_DP)
  Integer  :: neval, ifail
  Real(DP) :: errEstimate

  Interface linspace
     Module Procedure linspace,linspace_real
  End Interface linspace
  Interface integral
     Module Procedure integral, integralToInfty, integralOf, integralBreakPts
  End Interface integral

Contains

  !---------------------------------------------------------------------!
  !                                                                     !
  !                             Runge Kutta                             !
  !                                                                     !
  !---------------------------------------------------------------------!


  Subroutine rk4(y,dydx,x,h,yout,derivs)
    Use kinds; Use nrutil, Only : assert_eq
    Implicit None
    Real(DP), Dimension(:), Intent(IN) :: y,dydx
    Real(DP), Intent(IN) :: x,h
    Real(DP), Dimension(:), Intent(OUT) :: yout
    Interface
       Subroutine derivs(x,y,dydx)
         Use kinds
         Implicit None
         Real(DP), Intent(IN) :: x
         Real(DP), Dimension(:), Intent(IN) :: y
         Real(DP), Dimension(:), Intent(OUT) :: dydx
       End Subroutine derivs
    End Interface
    Integer(I4B) :: ndum
    Real(DP) :: h6,hh,xh
    Real(DP), Dimension(Size(y)) :: dym,dyt,yt
    ndum=assert_eq(Size(y),Size(dydx),Size(yout),'rk4')
    hh=h*0.5_dp
    h6=h/6.0_dp
    xh=x+hh
    yt=y+hh*dydx
    Call derivs(xh,yt,dyt)
    yt=y+hh*dyt
    Call derivs(xh,yt,dym)
    yt=y+h*dym
    dym=dyt+dym
    Call derivs(x+h,yt,dyt)
    yout=y+h6*(dydx+dyt+2.0_dp*dym)
  End Subroutine rk4

  !---------------------------------------------------------------------!
  !                                                                     !
  !                        Find first zero guess                        !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function GuessZero(fvals)
    Use Kinds
    Implicit None
    Real(DP),Dimension(:),Intent(in) :: fvals
    Integer                          :: GuessZero

    Integer                          :: jj

    Do jj=3,Size(fvals)
       If ( Sign( fvals(jj-1)/Abs(fvals(jj-1)) , fvals(jj)/Abs(fvals(jj)) ) .Ne. &
            Sign( fvals(jj-2)/Abs(fvals(jj-2)) , fvals(jj-1)/Abs(fvals(jj-1)) ) ) Exit
    End Do

    GuessZero = jj

  End Function GuessZero


  !---------------------------------------------------------------------!
  !                                                                     !
  !                           Newtons Method                            !
  !                                                                     !
  !---------------------------------------------------------------------!


  Function newton1D(fn,guess)
    Use Kinds
    Implicit None
    Real(DP) :: newton1D
    Interface
       Function fn(x)
         Use kinds
         Implicit None
         Real(DP)             :: fn
         Real(DP), Intent(in) :: x
       End Function fn
    End Interface
    Real(DP) :: guess
    ! Local Variables
    Real(DP) :: newt_tol = 1e-6
    Real(DP) :: h ! = 1e-6_DP
    Real(DP) :: fx, fxfh,fxbh, dfdx 
    Integer :: attempt
    Integer :: attempt_limit = 20
    Logical :: verbose = .False.

    If (verbose) Write(*,*) 'Newton-Raphson Method'
    h = guess * 1.0e-6_DP
    newton1D = guess
    attempt = 1

    Do
       fx = fn(newton1D)
       If (Abs(fx) <= newt_tol) Then
          If (verbose) Then
             Write(*,'(a,i3,a)') 'Success after', attempt, ' attempts.'
             Write(*,*) 'Zero  = ', newton1D
          End If
          Exit
       Else If (attempt >= attempt_limit) Then
          Write(*,*) 'Failed, change initial guess or increase attempt limit.'
          Exit
       End If

       fxfh = fn(newton1D + h/2)
       fxbh = fn(newton1D - h/2)
       dfdx = (fxfh-fxbh) / h
       newton1D = newton1D - fx / dfdx

       attempt = attempt + 1
    End Do
  End Function newton1D


  !---------------------------------------------------------------------!
  !                                                                     !
  !                          Linspace Function                          !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function linspace(start,finish,N)
    Integer                :: N
    Real(DP), Intent(in)   :: start, finish
    Real(DP), Dimension(N) :: linspace

    Real(DP)               :: int
    Integer                :: i

    linspace(1) = Real(start)
    linspace(N) = Real(finish)
    int  = (Real(finish)-start)/N

    Do i=2,N-1
       linspace(i)=linspace(i-1)+int
    End Do

  End Function linspace

  Function linspace_real(start,finish,N)
    Integer                :: N
    Real, Intent(in)       :: start, finish
    Real, Dimension(N)     :: linspace_real

    Real(DP)               :: int
    Integer                :: i

    linspace_real(1) = Real(start)
    linspace_real(N) = Real(finish)
    int  = (Real(finish)-start)/N

    Do i=2,N-1
       linspace_real(i)=linspace_real(i-1)+int
    End Do

  End Function linspace_real

  
  !---------------------------------------------------------------------!
  !                                                                     !
  !                          Finite Difference                          !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function deriv(f,x0)
    Use Kinds
    Implicit None
    Real(DP)                 :: deriv
    Interface
       Function f(x)
         Use kinds
         Implicit None
         Real(DP)            :: f
         Real(DP),Intent(in) :: x
       End Function f
    End Interface
    Real(DP),intent(in)      :: x0
    Real(DP)                 :: h,fxfh,fxbh
    
    h     = x0*1e-6_DP
    fxfh  = f(x0+h/2)
    fxbh  = f(x0-h/2)    
    deriv = (fxfh-fxbh)/h

  End Function deriv

  !---------------------------------------------------------------------!
  !                                                                     !
  !                      QuadPack Integral wrapper                      !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function integral(f, a, b, absErr, relErr)
    Implicit None
    Real(DP)                  :: integral
    Interface                                   ! Interfaces: Sections 5.11, 5.18
       Function f(x)
         Use kinds
         Implicit None
         Real(DP)             :: f
         Real(DP), Intent(in) :: x
       End Function f
    End Interface
    Real(DP), Intent(in)      :: a, b, absErr, relErr

    !  Local variables
    !
    Real(DP)                  :: integResult, bound=0.0_DP
    Integer                   :: inf

    !  Determine if the limits include infinity and call qagi if nessary
    !
    If (a == -Infty) Then
       If (b == Infty) Then
          inf=2
          Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
          If ( ifail /= 0 ) Then
             Write(*,*) 'Warning from qagi: the error code is ', ifail
          End If
       Else
          inf = -1
          bound = b
          Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
          If ( ifail /= 0 ) Then
             Write(*,*) 'Warning from qagi: the error code is ', ifail
          End If
       End If
    Else 
       If (b == Infty) Then
          inf = 1
          bound = a
          Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
          If ( ifail /= 0 ) Then
             Write(*,*) 'Warning from qagi: the error code is ', ifail
          End If
       Else
          Call qags(f, a, b, absErr, relErr, integResult, errEstimate, neval, ifail)
          If ( ifail /= 0 ) Then
             Write(*,*) 'Warning from qags: the error code is ', ifail
          End If
       End If
    End If
    integral = integResult

  End Function integral


  Function integralToInfty(f, bound, absErr, relErr)
    Implicit None
    Real(DP)                  :: integralToInfty
    Interface
       Function f(x)
         Use kinds
         Implicit None
         Real(DP)             :: f
         Real(DP), Intent(in) :: x
       End Function f
    End Interface
    Real(DP), Intent(in)      :: bound, absErr, relErr

    !  Local variables
    !
    Real(DP)                  :: integResult
    Integer, Parameter        :: inf=1

    Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
    If ( ifail /= 0 ) Then
       Write(*,*) 'Warning from qagi: the error code is ', ifail
    End If
    integralToInfty = integResult

  End Function integralToInfty


  Function integralOf(f, absErr, relErr)
    Implicit None
    Real(DP)                  :: integralOf
    Interface
       Function f(x)
         Implicit None
         Integer,  Parameter  :: DP = Kind(1.0d0)
         Real(DP)             :: f
         Real(DP), Intent(in) :: x
       End Function f
    End Interface
    Real(DP), Intent(in)      :: absErr, relErr

    !  Local variables
    !
    Real(DP)                  :: integResult, bound=0.0d0
    Integer, Parameter        :: inf=2

    Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
    If ( ifail /= 0 ) Then
       Write(*,*) 'Warning from qagi: the error code is ', ifail
    End If
    integralOf = integResult

  End Function integralOf


  Function integralBreakPts(f, a, b, absErr, relErr, nBreakPts, BreakPts)
    Implicit None
    Real(DP)                  :: integralBreakPts
    Interface
       Function f(x)
         Use kinds
         Implicit None
         Real(DP)             :: f
         Real(DP), Intent(in) :: x
       End Function f
    End Interface
    Real(DP), Intent(in)      :: a, b, absErr, relErr
    Integer,  Intent(in)      :: nBreakPts
    Real(DP), Intent(in), Dimension(nBreakPts) :: BreakPts

    !  Local variables
    !
    Real(DP)                         :: integResult
    Real(DP), Dimension(nBreakPts+2) :: BreakPtsP2        ! Automatic array.  Similar to allocatable arrays.

    BreakPtsP2(1:nBreakPts) = BreakPts(1:nBreakPts)       ! Array section limits are required here.

    Call qagp(f, a, b, nBreakPts+2, BreakPtsP2, absErr, relErr, integResult, errEstimate, neval, ifail)
    If ( ifail /= 0 ) Then
       Write(*,*) 'Warning from qagp: the error code is ', ifail
    End If
    integralBreakPts = integResult

  End Function integralBreakPts

End Module UsefulFunctions
