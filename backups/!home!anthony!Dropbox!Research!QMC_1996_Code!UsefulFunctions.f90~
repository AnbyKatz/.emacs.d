module UsefulFunctions
  use kinds
  use quadpack
  implicit none

  real(DP), parameter :: Infty = HUGE(1.0_DP)
  integer  :: neval, ifail
  real(DP) :: errEstimate

  INTERFACE linspace
     MODULE PROCEDURE linspace,linspace_int,linspace_real,linspace_intreal,linspace_intdp
  END INTERFACE linspace
  INTERFACE integral
     MODULE PROCEDURE integral, integralToInfty, integralOf, integralBreakPts
  END INTERFACE integral

contains

  !---------------------------------------------------------------------!
  !                                                                     !
  !                             Runge Kutta                             !
  !                                                                     !
  !---------------------------------------------------------------------!


  SUBROUTINE rk4(y,dydx,x,h,yout,derivs)
    USE kinds; USE nrutil, ONLY : assert_eq
    IMPLICIT NONE
    REAL(DP), DIMENSION(:), INTENT(IN) :: y,dydx
    REAL(DP), INTENT(IN) :: x,h
    REAL(DP), DIMENSION(:), INTENT(OUT) :: yout
    INTERFACE
       SUBROUTINE derivs(x,y,dydx)
         USE kinds
         IMPLICIT NONE
         REAL(DP), INTENT(IN) :: x
         REAL(DP), DIMENSION(:), INTENT(IN) :: y
         REAL(DP), DIMENSION(:), INTENT(OUT) :: dydx
       END SUBROUTINE derivs
    END INTERFACE
    INTEGER(I4B) :: ndum
    REAL(DP) :: h6,hh,xh
    REAL(DP), DIMENSION(size(y)) :: dym,dyt,yt
    ndum=assert_eq(size(y),size(dydx),size(yout),'rk4')
    hh=h*0.5_dp
    h6=h/6.0_dp
    xh=x+hh
    yt=y+hh*dydx
    call derivs(xh,yt,dyt)
    yt=y+hh*dyt
    call derivs(xh,yt,dym)
    yt=y+h*dym
    dym=dyt+dym
    call derivs(x+h,yt,dyt)
    yout=y+h6*(dydx+dyt+2.0_dp*dym)
  END SUBROUTINE rk4

  !---------------------------------------------------------------------!
  !                                                                     !
  !                        Find first zero guess                        !
  !                                                                     !
  !---------------------------------------------------------------------!

  function GuessZero(fvals)
    use Kinds
    implicit none
    real(DP),dimension(:),intent(in) :: fvals
    integer                          :: GuessZero

    integer                          :: jj

    do jj=3,size(fvals)
       if ( sign( fvals(jj-1)/abs(fvals(jj-1)) , fvals(jj)/abs(fvals(jj)) ) .ne. &
            sign( fvals(jj-2)/abs(fvals(jj-2)) , fvals(jj-1)/abs(fvals(jj-1)) ) ) exit
    end do

    GuessZero = jj

  end function GuessZero


  !---------------------------------------------------------------------!
  !                                                                     !
  !                           Newtons Method                            !
  !                                                                     !
  !---------------------------------------------------------------------!


  function newton1D(fn,guess)
    use Kinds
    implicit none
    real(DP) :: newton1D
    interface
       function fn(x)
         use kinds
         implicit none
         real(DP)             :: fn
         real(DP), intent(in) :: x
       end function fn
    end interface
    real(DP) :: guess
    ! Local Variables
    real(DP) :: newt_tol = 1e-6
    real(DP) :: h ! = 1e-6_DP
    real(DP) :: fx, fxph, dfdx ! fxph = fn(x+h)
    integer :: attempt
    integer :: attempt_limit = 20
    logical :: verbose = .false.

    if (verbose) write(*,*) 'Newton-Raphson Method'
    h = guess * 1.0e-6_DP
    newton1D = guess
    attempt = 1

    do
       fx = fn(newton1D)
       if (abs(fx) <= newt_tol) then
          if (verbose) then
             write(*,'(a,i3,a)') 'Success after', attempt, ' attempts.'
             write(*,*) 'Zero  = ', newton1D
          end if
          exit
       else if (attempt >= attempt_limit) then
          write(*,*) 'Failed, change initial guess or increase attempt limit.'
          exit
       end if

       fxph = fn(newton1D + h)
       dfdx = (fxph - fx) / h
       newton1D = newton1D - fx / dfdx

       attempt = attempt + 1
    end do
  end function newton1D


  !---------------------------------------------------------------------!
  !                                                                     !
  !                          Linspace Function                          !
  !                                                                     !
  !---------------------------------------------------------------------!

  function linspace(start,finish,N)
    integer                :: N
    real(DP), intent(in)   :: start, finish
    real(DP), dimension(N) :: linspace

    real(DP)               :: int
    integer                :: i

    linspace(1) = real(start)
    linspace(N) = real(finish)
    int  = (real(finish)-start)/N

    do i=2,N-1
       linspace(i)=linspace(i-1)+int
    end do

  end function linspace

  function linspace_int(start,finish,N)
    integer                :: N
    integer , intent(in)   :: start, finish
    real(DP), dimension(N) :: linspace_int

    real(DP)               :: int
    integer                :: i

    linspace_int(1) = real(start)
    linspace_int(N) = real(finish)
    int  = (real(finish)-real(start))/N

    do i=2,N-1
       linspace_int(i)=linspace_int(i-1)+int
    end do

  end function linspace_int

  function linspace_real(start,finish,N)
    integer                :: N
    real, intent(in)       :: start, finish
    real, dimension(N)     :: linspace_real

    real(DP)               :: int
    integer                :: i

    linspace_real(1) = real(start)
    linspace_real(N) = real(finish)
    int  = (real(finish)-start)/N

    do i=2,N-1
       linspace_real(i)=linspace_real(i-1)+int
    end do

  end function linspace_real

  function linspace_intreal(start,finish,N)
    integer                :: N
    real    , intent(in)   :: finish
    integer , intent(in)   :: start
    real(DP), dimension(N) :: linspace_intreal

    real(DP)               :: int
    integer                :: i

    linspace_intreal(1) = real(start)
    linspace_intreal(N) = real(finish)
    int  = (real(finish)-real(start))/N

    do i=2,N-1
       linspace_intreal(i)=linspace_intreal(i-1)+int
    end do

  end function linspace_intreal

  function linspace_intdp(start,finish,N)
    integer                :: N
    real(DP), intent(in)   :: finish
    integer , intent(in)   :: start
    real(DP), dimension(N) :: linspace_intdp

    real(DP)               :: int
    integer                :: i

    linspace_intdp(1) = real(start)
    linspace_intdp(N) = real(finish)
    int  = (real(finish)-real(start))/N

    do i=2,N-1
       linspace_intdp(i)=linspace_intdp(i-1)+int
    end do

  end function linspace_intdp


  !---------------------------------------------------------------------!
  !                                                                     !
  !                      QuadPack Integral wrapper                      !
  !                                                                     !
  !---------------------------------------------------------------------!

  function integral(f, a, b, absErr, relErr)
    implicit none
    real(DP)                  :: integral
    INTERFACE                                   ! Interfaces: Sections 5.11, 5.18
       FUNCTION f(x)
         USE kinds
         IMPLICIT NONE
         REAL(DP)             :: f
         REAL(DP), intent(in) :: x
       END FUNCTION f
    END INTERFACE
    real(DP), intent(in)      :: a, b, absErr, relErr

    !  Local variables
    !
    real(DP)                  :: integResult, bound=0.0_DP
    integer                   :: inf

    !  Determine if the limits include infinity and call qagi if nessary
    !
    if (a == -Infty) then
       if (b == Infty) then
          inf=2
          CALL qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
          if ( ifail /= 0 ) then
             write(*,*) 'Warning from qagi: the error code is ', ifail
          end if
       else
          inf = -1
          bound = b
          CALL qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
          if ( ifail /= 0 ) then
             write(*,*) 'Warning from qagi: the error code is ', ifail
          end if
       end if
    else 
       if (b == Infty) then
          inf = 1
          bound = a
          CALL qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
          if ( ifail /= 0 ) then
             write(*,*) 'Warning from qagi: the error code is ', ifail
          end if
       else
          CALL qags(f, a, b, absErr, relErr, integResult, errEstimate, neval, ifail)
          if ( ifail /= 0 ) then
             write(*,*) 'Warning from qags: the error code is ', ifail
          end if
       end if
    end if
    integral = integResult

  end function integral


  function integralToInfty(f, bound, absErr, relErr)
    implicit none
    real(DP)                  :: integralToInfty
    INTERFACE
       FUNCTION f(x)
         USE kinds
         IMPLICIT NONE
         REAL(DP)             :: f
         REAL(DP), intent(in) :: x
       END FUNCTION f
    END INTERFACE
    real(DP), intent(in)      :: bound, absErr, relErr

    !  Local variables
    !
    real(DP)                  :: integResult
    integer, parameter        :: inf=1

    CALL qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
    if ( ifail /= 0 ) then
       write(*,*) 'Warning from qagi: the error code is ', ifail
    end if
    integralToInfty = integResult

  end function integralToInfty


  function integralOf(f, absErr, relErr)
    implicit none
    real(DP)                  :: integralOf
    INTERFACE
       FUNCTION f(x)
         IMPLICIT NONE
         INTEGER,  parameter  :: DP = KIND(1.0d0)
         REAL(DP)             :: f
         REAL(DP), intent(in) :: x
       END FUNCTION f
    END INTERFACE
    real(DP), intent(in)      :: absErr, relErr

    !  Local variables
    !
    real(DP)                  :: integResult, bound=0.0d0
    integer, parameter        :: inf=2

    CALL qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
    if ( ifail /= 0 ) then
       write(*,*) 'Warning from qagi: the error code is ', ifail
    end if
    integralOf = integResult

  end function integralOf


  function integralBreakPts(f, a, b, absErr, relErr, nBreakPts, BreakPts)
    implicit none
    real(DP)                  :: integralBreakPts
    INTERFACE
       FUNCTION f(x)
         USE kinds
         IMPLICIT NONE
         REAL(DP)             :: f
         REAL(DP), intent(in) :: x
       END FUNCTION f
    END INTERFACE
    real(DP), intent(in)      :: a, b, absErr, relErr
    integer,  intent(in)      :: nBreakPts
    real(DP), intent(in), dimension(nBreakPts) :: BreakPts

    !  Local variables
    !
    real(DP)                         :: integResult
    real(DP), dimension(nBreakPts+2) :: BreakPtsP2        ! Automatic array.  Similar to allocatable arrays.

    BreakPtsP2(1:nBreakPts) = BreakPts(1:nBreakPts)       ! Array section limits are required here.

    CALL qagp(f, a, b, nBreakPts+2, BreakPtsP2, absErr, relErr, integResult, errEstimate, neval, ifail)
    if ( ifail /= 0 ) then
       write(*,*) 'Warning from qagp: the error code is ', ifail
    end if
    integralBreakPts = integResult

  end function integralBreakPts

end module UsefulFunctions
