program QMC_1996_CodeV3
  use usefulFunctions
  use Kinds
  use Pyplots
  implicit none

  integer ,parameter      :: N = 1e4
  integer                 :: ii,jj,ID,guess
  real(DP),dimension(N)   :: x_ax1,x_ax2,y_ax
  real(DP),dimension(N,6) :: data,data1,data2

  real(DP),dimension(3)   :: coupling,BagRadii
  real(DP)                :: x,Mq,Mn,fmMeV,Bag,z0,SIGfield, &
       Msigma,Rho0,RhoB,RB,S1,S2,     &
       sigma,a,b,absErr,relErr,       &
       Omega0,g_sigma,Meff,V,C,Mqef,  &
       dOmega0,var,xx,yval,ed

  !---------------------------------------------------------------------!
  !                                                                     !
  !                           Parameters Below                          !
  !                                                                     !
  !---------------------------------------------------------------------!

  coupling(1) = sqrt(5.86*4*pi)          !constant
  coupling(2) = sqrt(5.40*4*pi)          !constant
  coupling(3) = sqrt(5.07*4*pi)          !constant
  BagRadii(1) = 0.60_DP                  !fm
  BagRadii(2) = 0.80_DP                  !fm
  BagRadii(3) = 1.00_DP                  !fm


  ! Conversion Factor
  fmMeV  = 1/(197.327_DP)                !for fm -> MeV^{-1}

  !Set model parameters
  Mq     = 5_DP                          !MeV
  Mn     = 939_DP                        !MeV
  Rho0   = 0.16_DP                       !fm^{-3}
  Msigma = 550_DP                        !MeV
  x_ax1  = linspace(0.001_dp,Rho0*2.5,N) !fm^{-3}
  ed     = 400_DP                        !MeV
  absErr = 1e-6_DP
  relErr = 1e-6_DP
  a      = 0_DP

  !---------------------------------------------------------------------!
  !                                                                     !
  !                              Code Below                             !
  !                                                                     !
  !---------------------------------------------------------------------!

  do ii = 1,5,2
     data(:,ii) = x_ax1/Rho0
  end do

  do jj = 1,3                   

     Mqef    = Mq
     RB      = BagRadii(jj)*fmMeV
     g_sigma = coupling(jj)
     V       = (4/3.0)*pi*(RB**3)
     x_ax2   = linspace(0.001_dp,ed/g_sigma,N)

     call calculate_xOmega0(RB,Mqef,x,Omega0)

     dOmega0 = (2*(Mqef**2)*RB)/Omega0
     Bag     = (3.0/(16.0*pi*(RB**3)))*(MN - 3.0*dOmega0 )
     z0      = 3.0*Omega0 - MN*RB + Bag*(4.0/3.0)*pi*(RB**4)
     S1      = (Omega0/2+Mqef*RB*(Omega0-1))&
          /(Omega0*(Omega0-1)+(Mqef*RB)/2)


     do ii = 1,N
        sigma = x_ax2(ii)
        Mqef  = Mq - (1/(3*S1))*g_sigma*sigma     

        call calculate_xOmega0(RB,Mqef,x,Omega0)

        S2  = (Omega0/2+Mqef*RB*(Omega0-1))&
             /(Omega0*(Omega0-1)+(Mqef*RB)/2)

        C    = S2/S1
        Meff = (3*Omega0-z0)/RB + Bag*V
        xx = x_ax1(ii)

        call gsigmaVSrhob(RB,yval)
        data(ii,2*jj) = yval*g_Ïƒ

     end do

  end do

  call plot(data)



contains

  !---------------------------------------------------------------------!
  !                                                                     !
  !                    Calculates Bag constant and z0                   !
  !                                                                     !
  !---------------------------------------------------------------------!

  subroutine calculate_xOmega0(RB,Mqef,x,Omega0)
    real(DP), intent(in)       :: RB,Mqef
    real(DP), intent(out)      :: x,Omega0

    real(DP), dimension(N)     :: xvals,yvals_1,yvals_2,beta

    xvals      = linspace(0.01,6.0,N)  
    yvals_1    = sin(xvals)/xvals
    beta       = sqrt( (sqrt( xvals**2+(Mqef*RB)**2 ) - Mqef*RB ) &
         /( sqrt( xvals**2+(Mqef*RB)**2 ) + Mqef*RB ) )
    yvals_2    = beta*(sin(xvals)/(xvals**2)-cos(xvals)/xvals)
    guess  = GuessZero(yvals_1-yvals_2)

    x = newton1D(f1,xvals(guess))
    Omega0 = sqrt( x**2 + (Mqef*RB)**2 )

  end subroutine calculate_xOmega0

  function f1(x)
    real(DP),intent(in) :: x
    real(DP)            :: f1

    f1 = (sqrt( (sqrt( x**2+(Mqef*RB)**2 ) - Mqef*RB ) &
         /( sqrt( x**2+(Mqef*RB)**2 ) + Mqef*RB ) ))* &
         (sin(x)/(x**2)-cos(x)/x) - sin(x)/x         

  end function  f1

  function f2(x)
    real(DP), intent(in) :: x    
    real(DP)             :: f2

    f2 = (Meff*(x**2))/(SQRT( Meff**2 + x**2 ))

  end function f2

  function f3(x)
    real(DP),intent(in) :: x
    real(DP)            :: f3

    var = x
    f3  = (((g_sigma/Msigma**2)*C*(2/pi**2))&
         *integral(f2,a,b,absErr,relErr))-x

  end function f3

  subroutine gsigmaVSrhob(RB,yval)
    real(DP),intent(in)   :: RB
    real(DP),intent(out)  :: yval

    real(DP),dimension(N) :: yvals
    integer               :: kk

    RhoB = xx*(fmMeV**(-3))       !MeV^{3}
    b =(3*(pi**2)*RhoB/2)**(1/3.0)       !MeV

    do kk = 1,N
       var    = x_ax2(kk) 
       yvals(kk) = (((g_sigma/Msigma**2)*C*(2/pi**2))&
            *integral(f2,a,b,absErr,relErr))- var
    end do

    guess = GuessZero(yvals)
    yval = newton1D(f3,x_ax2(guess))

  end subroutine gsigmaVSrhob

end program QMC_1996_CodeV3
