Module UsefulFunctions
  Use kinds
  Use quadpack
  Implicit None

  Real(DP), Parameter :: Infty = Huge(1.0_DP)
  Integer  :: neval, ifail
  Real(DP) :: errEstimate

  Interface linspace
     Module Procedure linspace,linspace_real
  End Interface linspace
  Interface integral
     Module Procedure integral, integralToInfty, integralOf, integralBreakPts
  End Interface integral

Contains

  !---------------------------------------------------------------------!
  !                                                                     !
  !                        Runge Kutta algorithim                       !
  !                                                                     !
  !---------------------------------------------------------------------!

  subroutine rk4(t0,tN,y0,N,f,t,y)
    use kinds
    implicit none

    real(DP),intent(in) :: t0,tN,y0
    integer ,intent(in) :: N
    interface
       function f(t,y)
         use kinds
         implicit none
         real(DP)             :: f
         real(DP), intent(in) :: t,y
       end function f
    end interface
    real(DP),dimension(N),intent(out) :: y,t

    real(DP) :: h,k1,k2,k3,k4
    integer  :: i

    h = (tN-t0)/N

    do i = 1,N
       t(i) = t(0) + h*(i-1)
    end do

    y(:) = 0
    y(1) = y0

    do i = 1,N-1
       k1 = f(t(i),y(i))
       k2 = f(t(i)+0.5_dp*h,y(i)+0.5_dp*h*k1)
       k3 = f(t(i)+0.5_dp*h,y(i)+0.5_dp*h*k2)
       k4 = f(t(i)+h,y(i)+k3*h)       
       y(i+1) = y(i) + (1/6.0_dp)*(k1+2*k2+2*k3+k4)*h
    end do

  end subroutine rk4

  !---------------------------------------------------------------------!
  !                                                                     !
  !                        Find first zero guess                        !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function GuessZero(fvals)
    Use Kinds
    Implicit None
    Real(DP),Dimension(:),Intent(in) :: fvals
    Integer                          :: GuessZero

    Integer                          :: jj

    Do jj=3,Size(fvals)
       If ( Sign( fvals(jj-1)/Abs(fvals(jj-1)) , fvals(jj)/Abs(fvals(jj)) ) .Ne. &
            Sign( fvals(jj-2)/Abs(fvals(jj-2)) , fvals(jj-1)/Abs(fvals(jj-1)) ) ) Exit
    End Do

    GuessZero = jj

  End Function GuessZero


  !---------------------------------------------------------------------!
  !                                                                     !
  !                           Newtons Method                            !
  !                                                                     !
  !---------------------------------------------------------------------!


  Function newton1D(fn,guess)
    Use Kinds
    Implicit None
    Real(DP) :: newton1D
    Interface
       Function fn(x)
         Use kinds
         Implicit None
         Real(DP)             :: fn
         Real(DP), Intent(in) :: x
       End Function fn
    End Interface
    Real(DP) :: guess
    ! Local Variables
    Real(DP) :: newt_tol = 1e-6
    Real(DP) :: h ! = 1e-6_DP
    Real(DP) :: fx, fxfh,fxbh, dfdx 
    Integer :: attempt
    Integer :: attempt_limit = 20
    Logical :: verbose = .False.

    If (verbose) Write(*,*) 'Newton-Raphson Method'
    h = guess * 1.0e-6_DP
    newton1D = guess
    attempt = 1

    Do
       fx = fn(newton1D)
       If (Abs(fx) <= newt_tol) Then
          If (verbose) Then
             Write(*,'(a,i3,a)') 'Success after', attempt, ' attempts.'
             Write(*,*) 'Zero  = ', newton1D
          End If
          Exit
       Else If (attempt >= attempt_limit) Then
          Write(*,*) 'Failed, change initial guess or increase attempt limit.'
          Exit
       End If

       fxfh = fn(newton1D + h/2)
       fxbh = fn(newton1D - h/2)
       dfdx = (fxfh-fxbh) / h
       newton1D = newton1D - fx / dfdx

       attempt = attempt + 1
    End Do
  End Function newton1D


  !---------------------------------------------------------------------!
  !                                                                     !
  !                          Linspace Function                          !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function linspace(start,finish,N)
    Integer                :: N
    Real(DP), Intent(in)   :: start, finish
    Real(DP), Dimension(N) :: linspace

    Real(DP)               :: int
    Integer                :: i

    linspace(1) = start
    linspace(N) = finish
    int  = (Real(finish)-start)/(N-1)
    Do i=2,N-1
       linspace(i)=linspace(i-1)+int
    End Do

  End Function linspace

  Function linspace_real(start,finish,N)
    Integer                :: N
    Real, Intent(in)       :: start, finish
    Real, Dimension(N)     :: linspace_real

    Real(DP)               :: int
    Integer                :: i

    linspace_real(1) = start
    linspace_real(N) = finish
    int  = (Real(finish)-start)/(N-1)
    Do i=2,N-1
       linspace_real(i)=linspace_real(i-1)+int
    End Do

  End Function linspace_real

  !---------------------------------------------------------------------!
  !                                                                     !
  !                          Finite Difference                          !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function deriv(f,x0)
    Use Kinds
    Implicit None
    Real(DP)                 :: deriv
    Interface
       Function f(x)
         Use kinds
         Implicit None
         Real(DP)            :: f
         Real(DP),Intent(in) :: x
       End Function f
    End Interface
    Real(DP),intent(in)      :: x0
    Real(DP)                 :: h,fxfh,fxbh

    h     = x0*1e-6_DP
    fxfh  = f(x0+h/2)
    fxbh  = f(x0-h/2)    
    deriv = (fxfh-fxbh)/h

  End Function deriv

  !---------------------------------------------------------------------!
  !                                                                     !
  !                      QuadPack Integral wrapper                      !
  !                                                                     !
  !---------------------------------------------------------------------!

  Function integral(f, a, b, absErr, relErr)
    Implicit None
    Real(DP)                  :: integral
    Interface                                   ! Interfaces: Sections 5.11, 5.18
       Function f(x)
         Use kinds
         Implicit None
         Real(DP)             :: f
         Real(DP), Intent(in) :: x
       End Function f
    End Interface
    Real(DP), Intent(in)      :: a, b, absErr, relErr

    !  Local variables
    !
    Real(DP)                  :: integResult, bound=0.0_DP
    Integer                   :: inf

    !  Determine if the limits include infinity and call qagi if nessary
    !
    If (a == -Infty) Then
       If (b == Infty) Then
          inf=2
          Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
          If ( ifail /= 0 ) Then
             Write(*,*) 'Warning from qagi: the error code is ', ifail
          End If
       Else
          inf = -1
          bound = b
          Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
          If ( ifail /= 0 ) Then
             Write(*,*) 'Warning from qagi: the error code is ', ifail
          End If
       End If
    Else 
       If (b == Infty) Then
          inf = 1
          bound = a
          Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
          If ( ifail /= 0 ) Then
             Write(*,*) 'Warning from qagi: the error code is ', ifail
          End If
       Else
          Call qags(f, a, b, absErr, relErr, integResult, errEstimate, neval, ifail)
          If ( ifail /= 0 ) Then
             Write(*,*) 'Warning from qags: the error code is ', ifail
          End If
       End If
    End If
    integral = integResult

  End Function integral


  Function integralToInfty(f, bound, absErr, relErr)
    Implicit None
    Real(DP)                  :: integralToInfty
    Interface
       Function f(x)
         Use kinds
         Implicit None
         Real(DP)             :: f
         Real(DP), Intent(in) :: x
       End Function f
    End Interface
    Real(DP), Intent(in)      :: bound, absErr, relErr

    !  Local variables
    !
    Real(DP)                  :: integResult
    Integer, Parameter        :: inf=1

    Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
    If ( ifail /= 0 ) Then
       Write(*,*) 'Warning from qagi: the error code is ', ifail
    End If
    integralToInfty = integResult

  End Function integralToInfty


  Function integralOf(f, absErr, relErr)
    Implicit None
    Real(DP)                  :: integralOf
    Interface
       Function f(x)
         Implicit None
         Integer,  Parameter  :: DP = Kind(1.0d0)
         Real(DP)             :: f
         Real(DP), Intent(in) :: x
       End Function f
    End Interface
    Real(DP), Intent(in)      :: absErr, relErr

    !  Local variables
    !
    Real(DP)                  :: integResult, bound=0.0d0
    Integer, Parameter        :: inf=2

    Call qagi(f, bound, inf, absErr, relErr, integResult, errEstimate, neval, ifail)
    If ( ifail /= 0 ) Then
       Write(*,*) 'Warning from qagi: the error code is ', ifail
    End If
    integralOf = integResult

  End Function integralOf


  Function integralBreakPts(f, a, b, absErr, relErr, nBreakPts, BreakPts)
    Implicit None
    Real(DP)                  :: integralBreakPts
    Interface
       Function f(x)
         Use kinds
         Implicit None
         Real(DP)             :: f
         Real(DP), Intent(in) :: x
       End Function f
    End Interface
    Real(DP), Intent(in)      :: a, b, absErr, relErr
    Integer,  Intent(in)      :: nBreakPts
    Real(DP), Intent(in), Dimension(nBreakPts) :: BreakPts

    !  Local variables
    !
    Real(DP)                         :: integResult
    Real(DP), Dimension(nBreakPts+2) :: BreakPtsP2        ! Automatic array.  Similar to allocatable arrays.

    BreakPtsP2(1:nBreakPts) = BreakPts(1:nBreakPts)       ! Array section limits are required here.

    Call qagp(f, a, b, nBreakPts+2, BreakPtsP2, absErr, relErr, integResult, errEstimate, neval, ifail)
    If ( ifail /= 0 ) Then
       Write(*,*) 'Warning from qagp: the error code is ', ifail
    End If
    integralBreakPts = integResult

  End Function integralBreakPts

End Module UsefulFunctions
