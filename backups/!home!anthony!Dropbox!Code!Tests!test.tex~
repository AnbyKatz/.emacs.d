% Created 2018-08-05 Sun 22:49
% Intended LaTeX compiler: pdflatex
\documentclass[aps,prl,twocolumn]{revtex4-1}{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{mypackage}
\author{Anthony Kalaitzis}
\date{\today}
\title{Paper Title}
\hypersetup{
 pdfauthor={Anthony Kalaitzis},
 pdftitle={Paper Title},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.0.50 (Org mode 9.1.13)}, 
 pdflang={English}}
\begin{document}

\maketitle


\section{Introduction}
\label{sec:org161daa1}

The following report details calculating the power spectra for a ball with a given driving frequency. We will analyze the effects of averaging over a collection of copies of the system and applying windows to the data. These steps will allow us to discuss the effects of noise on our system produced via the Fourier transform and other artifacts such as leakage.

\section{Finding the Power Spectra}
\label{sec:org1df08a0}
We start by loading our data into Matlab for manipulation, where the first column represents the driving frequency (after Fourier transform) that we will use to create the frequency axis. The second column of data being the height of the ball.

Before Fourier transforming our data, it is important to truncate to $2^n$ data points where $n\inN$. We have 70000 data points so the greatest power of 2 which is less then the total number of data points is $2^{16}=65536$. Hence we may simply read off the first $2^{16}$ points to truncate our data like so. This is due to Matlab's algorithms creating zeros in the data to force the dimension to be a power of 2.

Using Matlab's inbuilt discrete Fourier transform function on our data returns the Fourier transform of the data. We then simply calculate the absolute value squared, divided by the number of points squared of both Fourier transforms to get the power values for both.

This gives us our power values for the y axis but we still wish for a properly calibrated x axis. We construct this x axis based of the Fourier transform of the driver data which represents a 145Hz sine wave. Since this is the Fourier transform of a sine wave of 145Hz, we expect a peak at 145Hz.

We may observe these peaks clearly by simply plotting the power spectra data directly on a log plot. In this case we don't add an x axis so Matlab will simply make the x axis the index set of natural numbers. This gives us FIG. \ref{fig1}
  
Suppose $i$ represents the index labelling where the Fourier transformed driver obtains its maximum value. We can then find the sampling frequency $f_s$ by the formula
\begin{align*}
  f_s=\frac{f}{i}N
\end{align*}
where $f$ is the frequency and $N$ the number of data points. This will scale our data space to produce a properly calibrated x axis. Next create a space of points equal in length to the number of data points and centred at 0 i.e. from $-N/2$ to $N/2-1$. This can be done in Matlab like so

We may use this frequency axis and plot it against our previously calculated power values for both columns. It is important though to use Matlab's \texttt{fftshift} function to ensure the negative values of the Fourier transform don't contaminate the output. This produces FIG \ref{fig2}

The code used to display this plot is provided below

One extra detail we have calculated and displayed as a vertical line on the plot is the nyquist frequency which tells us that any frequencies sampled greater then the nyquist frequency will be aliased. This feature will also be shown in later plots. To calculate the nyquist frequency we simply use the formula that

where $f_s$ is the sampling frequency previously discussed. We can see on our plot that we indeed do not sample any frequencies greater then the nyquist frequency. So no aliasing will occur due to overlaying peaks but some aliasing may still occur due to noise and other factors which will be discussed later.

\section{Averaging and Noise Examination}
\label{sec:org18c9b2b}

We wish to try different averaging strategies to reduce noise. One such strategy would be to break up the data into $N$ chunks and average over the Fourier transform of the chunks to produce a new data set of $N$ points. We would then simply follow the previous steps as with the first section to perform the Fourier transform of the data and plot.

Consider the following method: We have $2^{16}$ data points after truncation so if we divide into $2^N$ chunks where $N\inN$ we won't have any segmentation errors. To do this, consider the following code

We started by choosing the amount of chunks to divide the data into and then creating index vectors to identify the elements of these array chunks. We did the end points manually as indexing issues can occur. Next calculate the Fourier transform of these chunks and then average over the chunks to produce our new data set of length $N$.

Following from the previous code then gives us FIG \ref{fig3} and FIG \ref{fig4} which are the plots for 8 and 16 ensembles respectively.

  Another such strategy instead would be to take every $2^n$ data points i.e. originally we had a step size of 1 but now we change it to $2^n$ and then average over the produced sequences. For instance, we can take every eighth point in the data stream, Fourier transform this data and then increment to the next sequence of data and average. This is demonstrated below for the case of taking every eighth point.
\end{document}
